	Структура хранения людей:

Есть у нас некоторое множество людей, shared_ptr'ы на которых хранятся в контейнере people (предварительно list), а также контейнеры staff'ы - персонал служб и всякие дополнительные контейнеры (обучающиеся, старики и т. п.). Всё хранится в population, потому что он взаимодействует с ними больше всех, а все остальные службы обращается к своим контейнерам в population. В population будут методы, которые возвращают ссылку на эти контейнеры.

	Примерный план работы обработки людей:

1. Отработали службы в рамках следующей логики обработки людей:

Если какая-то служба хочет убить какого-то человека A, то она должна выполнить следующую логику:

В своём staff'e (который представляет контейнер shared_ptr на людей) у человека полю is_alive присваивается false и всё, больше ничего делать не нужно.

2. В игру вступает population:

В самом начале идёт логика убыли населения (естественная смерть), то есть пробегаем по массиву people и проставляем у людей is_alive = false.

Он бегает по всем свои контейнерам и pop'ет от туда shared_ptr'ы на мёртвых людей (критерий is_alive == false), то есть тех, кто умерли неестевенной смертью. (Когда какой-то shared_ptr удалился из всех контейнеров, где он находился, он автоматически освобождает память, лекции в помощь.)

Далее идёт логика прироста (рождение детей, создание в пробирке и т. п.).

Заключает этот алгоритм логика распределения людей по службам в соответсвии с требованиями служб, то есть требуется распределить людей, которые прошли обучение (логика обучения с социальной службы) и готовы к работе. Требуемое количество людей можно на первых порах реализовать простой моделью (количество людей, требуемое для работы службы) - (количество живых людей работающих в этой службе).
Каждая служба должна будет перегрузить следующий метод из service: 

virtual void get_staff_request() = 0;